Documentation for the Server portion of AI-Foosball Spring 2022 Senior Design Project.

# Main Server

## Purpose
This module serves as a single source of truth for all data in the program. Each other module either generates data that is sent 
to the server or requests data from the server. Providing a single point of data transfer ensures that each additional module only
requires one socket connection for communication with any other part of the system. Providing a layer of abstraction preventing clients
from needed any understanding of the operation of other topics. The server functions by maintaining a dictionary object called the 
GameState which holds the key,value pair of all data sent to the server. Communication occurs by clients sending their own dictionaries 
formatted as JSON strings that the server then uses to update or add to the GameState. Requests for data see clients sending a dictionary
holding the requested values where the server compares keys and returns its stored values. If running a python file, the Message.py file 
can be used to automatically format python dictionary objects to JSON strings for sending. Clients in other language must handle the 
JSON formatting manually. 

## Values Available in GameState
### Rod Data
values for specific rods follow this format `robot_(rod descriptor)_rod_(displacement/angle)_(current/command)`

rod descriptors include (goal, 2, 5, 3) denoting which rod is referenced by the number of players

displacement/angle denotes which axis of the rod is referenced

current values are generated by the moter controllers indicating the position the rod thinks it is in

command values are generated by the finite state machine and indicate the position rods should move to

example full value being `"robot_goal_rod_displacement_command":143`

all values in milimeters

### Ball Data
- ball_x: x position of the ball
- ball_y: y position of the ball
- ball_Vx: x component of ball velocity
- ball_Vy: y component of ball velocity
- float values in mm and mm/s

### Game Data
- game_flag: boolean value indicating if a game has been started
- pause: boolean value indicating if the game is paused
- stop: boolean value indicating if the rods are stopped
- player_score: the score of the human player
- robot_score: the score of the robot player

### CAN DATA
- USB2CAN: success or error message from CAN initialization
- unknown CAN messages are posted with their id as the key and data as the value, both in hexadecimal representation

## Files
### GameState.py
class file for the game state, initialized with an empty dictionary 

update_game_data: takes an input dictionary and updates local dictionary. new keys are added and shared keys get updated values

get_game_data:updates values of the input dictionary with the values from identical keys in game state. Keys that can not be 
located are filled with the string "not found"

get_all_data:returns the entire game state dictionary

### GameServer.py
This is the actual server file and utilizes the concept of a python selector. Selectors allow for sequential handling of 
multiple socket connections. A sequential server was created as it eliminated the possibility of race conditions or other
data access errors that occur from threading. In addition sequential processing still proved to be fast enough for our 
purposes. I would highly caution against changing the functioning of the server.

The server exists on port 5000 of the raspberry pi with the current ip address of 192.168.0.1

The server waits in an infinite loop for connections from clients. When a message is sent the server checks if the socket exists
in the selector, if not the accept_wrapper function is called where the socket information is added to the selector.
Subsequent read or write requests are then recognized by the selector in the service_connection method.

Service connection first checks if the client requested a read or write. With writes, any data stored in the selector for the
socket is sent. Reads start by reading the first four bytes of the message, which must be an integer denoting the length of the 
rest of the message. Once the rest of the message is read it is converted from a JSON to a dictionary object. This dictionary
must contain a key denoted "action" with a value indicating the service requested by the client. Available actions include "POST",
"GET", and "DUMP". POST adds the sent dictionary to the game state. GET creates a dictionary of the requested values and fromats
them to be sent back to the client before saving the data back to the selector. DUMP acts similarly including every value 
currently in the game state. If anything goes wrong, a dictionary key "error" will be included with an error message. 

Clients should send an empty byte string to close the socket connection on the server. Additionally messages from the server 
are not prefaced with their byte length

### Message.py
The message class serves to abstract communication to the server for clients written in python. Clients not using this 
class must send an integer length and JSON formatted dictionary manually to the server. 

Initialization of a message creates an empty dictionary and requires an action string. Known actions by the server are POST, 
GET, and DUMP. The python update method can then be used to add any other key, value pairs to the message dictionary. When ready
to send, encode_to_send(True) creates a binary string with length header that is ready to be sent to the server. Using False 
does not add a length header. 

`message = Message("GET")`

`message.data.update(server_data)`

`sock.sendall(message.encode_to_send(True))`

Decoding can be done by creating a message object and using the method decode_from_receive on the binary data

`recv_data = sock.recv(1024)`

`received = Message("RECEIVED")`

`received.decode_from_receive(recv_data)`

The dictionary of this message now contains the returned data

### can_com.py
The purpose of this code is to handle sending messages between the CAN and the server.

initializeSocket will connect to the server if the server is running and will loop trying to connect if the server is not running 

initializeCan will create a CAN connection if the USB2CAN adapter is connected to the pi
This will keep looping if it does not connect and will update the server on its connection status

receiveCan will receive messages from the CAN bus and will decode them according to our premade CAN messages.
It will look for which rod is communicating along with its current position
It will also get the goal messages from the CAN bus
This ends with posting all of the information to the server

sendCan will request specific information from the server
The information received is determined by the local dictionary in the function
It will look for the game to be started before it continues.
When the game is started, it will send an initial zero command to each rod as well as reset the score in the CAN
This then takes the messages and decodes them to determine the translational and rotational desired location of each rod
It then sends four messages to the CAN with a 10ms delay, one for each rod

The try block calls the initializeSocket twice, one socket for receiveCan and one for sendCan
This then calls initializeCan 
Last it will create two threads so the receiveCan and sendCan will run constantly and simultaneously. 

### Other Files
Other files in this directory cantain various tests for specific functionality including message passing to the server and reading data

